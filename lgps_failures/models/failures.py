# -*- coding: utf-8 -*-

from odoo import api, models, fields, _
import re
import logging
_logger = logging.getLogger(__name__)


class Failures(models.Model):
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _name = 'lgps.failures'
    _description = _("Failures")

    def get_filtered_failures_options(self):
        selection_list = list()

        if self.env.user.has_group('lgps.lgps_group_quality_operations'):
            options = self.env['lgps.failures_list'].sudo().search([])

            for option in options:
                selection_list.append(option.id)
        else:
            options = self.env['lgps.failures_list'].sudo().search([('restricted', '=', False)])
            for option in options:
                selection_list.append(option.id)

        return selection_list

    name = fields.Char(
        required=True,
        string=_("Internal Id"),
        default="Autogenerated on Save",
    )

    product_id = fields.Many2one(
        comodel_name="product.product",
        string=_("Product Type"),
        domain=[
            ('sale_ok', '=', True),
            ('detailed_type', '=', 'product')
        ],
        ondelete="restrict",
        index=True,
    )

    client_id = fields.Many2one(
        comodel_name="res.partner",
        string=_("Installed On"),
        domain=[
            ('active', '=', True),
            ('is_company', '=', True)
        ],
        index=True,
        tracking=True,
    )

    failures_categories_list_id = fields.Many2one(
        comodel_name="lgps.failures_categories_list",
        string=_("Failures Categories List"),
        ondelete="restrict",
        index=True,
        # domain=lambda self: [('id', 'in', self.get_filtered_failures_options())]
    )

    failures_list_id = fields.Many2one(
        comodel_name="lgps.failures_list",
        string=_("Failures List"),
        ondelete="restrict",
        index=True,
        # domain=lambda self: [('id', 'in', self.get_filtered_failures_options())]
    )

    failures_root_problem_list_id = fields.Many2one(
        comodel_name="lgps.failure_root_problem_list",
        string=_("Failures Root Problem List"),
        ondelete="restrict",
        index=True,
    )

    report_date = fields.Date(
        default=fields.Date.today,
        string=_("Report Date"),
        tracking=True,
    )

    serial_number_id = fields.Many2one(
        comodel_name="stock.production.lot",
        string=_("Serial Number"),
        ondelete="restrict",
        index=True,
    )

    repairs_id = fields.Many2one(
        comodel_name="project.task",
        ondelete="restrict",
        string=_("ODT"),
        index=True,
        tracking=True,
        required="True"
    )

    internal_notes = fields.Text(
        string=_('Internal Notes')
    )

    manipulation_detected = fields.Boolean(
        string=_("Detected Manipulation"),
        default=False
    )

    time_spent = fields.Float(
        string=_("Time Spent"),
        help='Time spent in solution to this record',
        tracking=True,
    )

    @api.model
    def create(self, vals):
        seq = self.env['ir.sequence'].next_by_code('lgps.failures') or _('New')
        vals['name'] = seq
        return super(Failures, self).create(vals)

    def copy(self, default=None):
        default = dict(default or {})

        copied_count = self.search_count(
            [('name', '=like', u"Copy of {}%".format(self.name))])
        if not copied_count:
            new_name = u"Copy of {}".format(self.name)
        else:
            new_name = u"Copy of {} ({})".format(self.name, copied_count)

        default['name'] = new_name
        return super(Failures, self).copy(default)

    _sql_constraints = [
        ('name_unique',
         'UNIQUE(name)',
         "The failure id must be unique"),
    ]

    @api.onchange('product_id')
    def onchange_m2o(self):
        domain = {}
        if self.product_id:
            list_ids = []
            values = self.env['stock.production.lot'].search(
                [('product_id', '=', self.product_id.id)])

            for value in values:
                list_ids.append(value.id)

            domain = {'serial_number_id': [('id', 'in', list_ids)]}

        return {'domain': domain}

    @api.onchange('failures_categories_list_id')
    def _onchange_failures_categories_list_id(self):
        domain = {}
        _logger.warning('failures_categories_list_id: %s', self.failures_categories_list_id)
        if self.failures_categories_list_id:
            list_ids = []
            product_ids = []
            values = self.env['lgps.failures_list'].search([('failures_categories_list_id', '=', self.failures_categories_list_id.id)])
            _logger.warning('values: %s', values)
            for value in values:
                list_ids.append(value.id)

            products = self.env['product.template'].search([('categories_list_id', '=', self.failures_categories_list_id.id)])
            for product in products:
                product_ids.append(product.id)

            self.product_id = []
            self.failures_list_id = []
            self.failures_root_problem_list_id = []

            domain = {
                'failures_list_id': [('id', 'in', list_ids)],
                'product_id': [('id', 'in', product_ids)],
            }

        return {'domain': domain}

    @api.onchange('failures_list_id')
    def _onchange_failures_list_id(self):
        domain = {}
        _logger.warning('failures_list_id: %s', self.failures_list_id)
        if self.failures_list_id:
            list_ids = []
            values = self.env['lgps.failure_root_problem_list'].search(
                [('failures_list_ids', 'in', self.failures_list_id.id)])

            _logger.warning('values: %s', values)

            for value in values:
                list_ids.append(value.id)

            self.failures_root_problem_list_id = []

            domain = {
                'failures_root_problem_list_id': [('id', 'in', list_ids)],
            }

        return {'domain': domain}

    def _check_no_warranty_rules(self, field):
        if not self.manipulation_detected:
            if field:
                if re.search('manipulaci', field, re.IGNORECASE):
                    self.manipulation_detected = True
                else:
                    self.manipulation_detected = False

        return

    def _check_if_invalidate(self, invalidate):
        if not self.manipulation_detected:
            if invalidate:
                self.manipulation_detected = True
        return
